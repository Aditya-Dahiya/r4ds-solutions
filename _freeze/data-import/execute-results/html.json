{
  "hash": "081bb48b0db5d3aeab6f788c2426c131",
  "result": {
    "markdown": "---\ntitle: \"Data import\"\n---\n\n\n\n\n## Prerequisites {.unnumbered}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n#> ── Attaching core tidyverse packages ───────────────────── tidyverse 2.0.0 ──\n#> ✔ dplyr     1.1.2     ✔ readr     2.1.4\n#> ✔ forcats   1.0.0     ✔ stringr   1.5.0\n#> ✔ ggplot2   3.4.2     ✔ tibble    3.2.1\n#> ✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n#> ✔ purrr     1.0.1     \n#> ── Conflicts ─────────────────────────────────────── tidyverse_conflicts() ──\n#> ✖ dplyr::filter() masks stats::filter()\n#> ✖ dplyr::lag()    masks stats::lag()\n#> ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n:::\n\n\n## 8.2.4 Exercises {.unnumbered}\n\n1.  For reading a file delimited with `|`, use `read_delim()` with argument `delim = \"|\"`.\n\n2.  All other arguments are common among the two functions.\n\n3.  `col_positions` is an important argument since it defines the beginning and end of columns.\n\n4.  We need to specify the `quote` argument.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    read_csv(\"x,y\\n1,'a,b'\", quote = \"\\'\")\n    #> Rows: 1 Columns: 2\n    #> ── Column specification ─────────────────────────────────────────────────────\n    #> Delimiter: \",\"\n    #> chr (1): y\n    #> dbl (1): x\n    #> \n    #> ℹ Use `spec()` to retrieve the full column specification for this data.\n    #> ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n    #> # A tibble: 1 × 2\n    #>       x y    \n    #>   <dbl> <chr>\n    #> 1     1 a,b\n    ```\n    :::\n\n\n5.  Problems with each `read_csv()` statement is shown below:\\\\\n\n    -   There are only two column headers but three values in each row, so the last two get merged:\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        read_csv(\"a,b\\n1,2,3\\n4,5,6\")\n        #> Warning: One or more parsing issues, call `problems()` on your data frame for\n        #> details, e.g.:\n        #>   dat <- vroom(...)\n        #>   problems(dat)\n        #> Rows: 2 Columns: 2\n        #> ── Column specification ─────────────────────────────────────────────────────\n        #> Delimiter: \",\"\n        #> dbl (1): a\n        #> num (1): b\n        #> \n        #> ℹ Use `spec()` to retrieve the full column specification for this data.\n        #> ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n        #> # A tibble: 2 × 2\n        #>       a     b\n        #>   <dbl> <dbl>\n        #> 1     1    23\n        #> 2     4    56\n        ```\n        :::\n\n\n    -   There are only three column headers, first row is missing a value in the last column so gets an `NA` there, the second row has four values so the last two get merged:\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        read_csv(\"a,b,c\\n1,2\\n1,2,3,4\")\n        #> Warning: One or more parsing issues, call `problems()` on your data frame for\n        #> details, e.g.:\n        #>   dat <- vroom(...)\n        #>   problems(dat)\n        #> Rows: 2 Columns: 3\n        #> ── Column specification ─────────────────────────────────────────────────────\n        #> Delimiter: \",\"\n        #> dbl (2): a, b\n        #> num (1): c\n        #> \n        #> ℹ Use `spec()` to retrieve the full column specification for this data.\n        #> ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n        #> # A tibble: 2 × 3\n        #>       a     b     c\n        #>   <dbl> <dbl> <dbl>\n        #> 1     1     2    NA\n        #> 2     1     2    34\n        ```\n        :::\n\n\n    -   No rows are read in:\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        read_csv(\"a,b\\n\\\"1\")\n        #> Rows: 0 Columns: 2\n        #> ── Column specification ─────────────────────────────────────────────────────\n        #> Delimiter: \",\"\n        #> chr (2): a, b\n        #> \n        #> ℹ Use `spec()` to retrieve the full column specification for this data.\n        #> ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n        #> # A tibble: 0 × 2\n        #> # ℹ 2 variables: a <chr>, b <chr>\n        ```\n        :::\n\n\n    -   Each column has a numerical and a character value, so the column type is coerced to character:\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        read_csv(\"a,b\\n1,2\\na,b\")\n        #> Rows: 2 Columns: 2\n        #> ── Column specification ─────────────────────────────────────────────────────\n        #> Delimiter: \",\"\n        #> chr (2): a, b\n        #> \n        #> ℹ Use `spec()` to retrieve the full column specification for this data.\n        #> ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n        #> # A tibble: 2 × 2\n        #>   a     b    \n        #>   <chr> <chr>\n        #> 1 1     2    \n        #> 2 a     b\n        ```\n        :::\n\n\n    -   The delimiter is `;` but it's not specified, therefore this is read in as a single-column data frame with a single observation:\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        read_csv(\"a;b\\n1;3\")\n        #> Rows: 1 Columns: 1\n        #> ── Column specification ─────────────────────────────────────────────────────\n        #> Delimiter: \",\"\n        #> chr (1): a;b\n        #> \n        #> ℹ Use `spec()` to retrieve the full column specification for this data.\n        #> ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n        #> # A tibble: 1 × 1\n        #>   `a;b`\n        #>   <chr>\n        #> 1 1;3\n        ```\n        :::\n\n\n6.  The non-syntactic names can be read in as follows.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    annoying <- tibble(\n      `1` = 1:10,\n      `2` = `1` * 2 + rnorm(length(`1`))\n    )\n    ```\n    :::\n\n\n    a.  Extracting the variable called `1`:\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    annoying |>\n      select(`1`)\n    #> # A tibble: 10 × 1\n    #>     `1`\n    #>   <int>\n    #> 1     1\n    #> 2     2\n    #> 3     3\n    #> 4     4\n    #> 5     5\n    #> 6     6\n    #> # ℹ 4 more rows\n    ```\n    :::\n\n\n    b.  Plotting a scatterplot of `1` vs. `2`:\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    ggplot(annoying, aes(x = `2`, y = `1`)) +\n      geom_point()\n    ```\n    \n    ::: {.cell-output-display}\n    ![](data-import_files/figure-html/unnamed-chunk-11-1.png){width=576}\n    :::\n    :::\n\n\n    c.  Creating a new column called `3`, which is `2` divided by `1`:\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    annoying |>\n      mutate(`3` = `2` / `1`)\n    #> # A tibble: 10 × 3\n    #>     `1`    `2`   `3`\n    #>   <int>  <dbl> <dbl>\n    #> 1     1  0.600 0.600\n    #> 2     2  4.26  2.13 \n    #> 3     3  3.56  1.19 \n    #> 4     4  7.99  2.00 \n    #> 5     5 10.6   2.12 \n    #> 6     6 13.1   2.19 \n    #> # ℹ 4 more rows\n    ```\n    :::\n\n\n    d.  Renaming the columns to `one`, `two`, and `three`:\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    annoying |>\n      mutate(`3` = `2` / `1`) |>\n      rename(\n        \"one\" = `1`,\n        \"two\" = `2`,\n        \"three\" = `3`\n      )\n    #> # A tibble: 10 × 3\n    #>     one    two three\n    #>   <int>  <dbl> <dbl>\n    #> 1     1  0.600 0.600\n    #> 2     2  4.26  2.13 \n    #> 3     3  3.56  1.19 \n    #> 4     4  7.99  2.00 \n    #> 5     5 10.6   2.12 \n    #> 6     6 13.1   2.19 \n    #> # ℹ 4 more rows\n    ```\n    :::\n",
    "supporting": [
      "data-import_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}