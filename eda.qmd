---
title: "Exploratory data analysis"
---

```{r}
#| results: "asis"
#| echo: false

source("_common.R")
```

## Prerequisites {.unnumbered}

```{r}
library(tidyverse)
library(ggbeeswarm)
library(lvplot)
```

## 11.3.3 Exercises {.unnumbered}

1.  All distributions are multimodal, right skewed, and have extreme outliers.

    ```{r}
    #| layout-ncol: 3

    ggplot(diamonds, aes(x = x)) +
      geom_histogram(binwidth = 0.01)
    ggplot(diamonds, aes(x = y)) +
      geom_histogram(binwidth = 0.01)
    ggplot(diamonds, aes(x = z)) +
      geom_histogram(binwidth = 0.01)
    ```

    Typical values for `x` and `y` are larger than `z`, which might suggest `z` is the depth, which matches up with the documentation. Typical values for `x` and `y` are ver similar, but the maximum for `y` is much higher, therefore I would guess that `y` is width, since we generally expect width to be larger than length.

    ```{r}
    diamonds |>
      select(x, y, z) |>
      pivot_longer(cols = everything(), names_to = "measurement") |>
      group_by(measurement) |>
      summarize(
        min = min(value),
        mean = mean(value),
        median = median(value),
        sd = sd(value),
        iqr = IQR(value),
        max = max(value)
      )
    ```

```{=html}
<!-- -->
```
2.  The distribution of price is right skewed with a median of \$2,401.
    There is a gap in the distribution with very few diamonds around \$1,500, which is curious -- I can't think of a specific reason why that would be the case.

    ```{r}
    #| fig-width: 8

    ggplot(diamonds, aes(x = price)) + 
      geom_histogram(binwidth = 100) +
      scale_x_continuous(breaks = seq(0, 20000, 2000))
    ```

    ```{r}
    diamonds |>
      summarize(
        min = min(price),
        mean = mean(price),
        median = median(price),
        sd = sd(price),
        iqr = IQR(price),
        max = max(price)
      )
    ```

```{=html}
<!-- -->
```
3.  Only 23 diamonds are 0.99 carats and 1,558 diamonds are 1 carat.
    This is likely because the market for 0.99 carat diamonds is small.
    If you can get a 1 carat diamond for just a little but of increase in price.
    We can see that the typical price for a 1 carat diamond is less than \$100 more than the typical price for a 0.99 carat diamond.
    For that small a difference, compared to the actual price of a diamond, many people might be willing to go up to a full carat.

    ```{r}
    diamonds |>
      filter(carat %in% c(0.99, 1)) |>
      group_by(carat) |>
      summarize(
        n = n(),
        median_price = median(price)
      )
    ```

4.  Specifying `xlim()` filters out any observations not in the specified range while specifying the `xlim` argument in `coord_cartesian()` zooms into the original plot without filtering.

    ```{r}
    #| layout-ncol: 3

    ggplot(diamonds, aes(x = price)) +
      geom_histogram(binwidth = 500)
    ggplot(diamonds, aes(x = price)) +
      geom_histogram(binwidth = 500) +
      xlim(0, 5000)
    ggplot(diamonds, aes(x = price)) +
      geom_histogram(binwidth = 500) +
      coord_cartesian(xlim = c(0, 5000))
    ```

    This is similar for specifying limits for `y` as well.

    ```{r}
    ggplot(diamonds, aes(x = price)) +
      geom_histogram(binwidth = 500)
    ggplot(diamonds, aes(x = price)) +
      geom_histogram(binwidth = 500) +
      ylim(0, 1000)
    ggplot(diamonds, aes(x = price)) +
      geom_histogram(binwidth = 500) +
      coord_cartesian(ylim = c(0, 1000))
    ```

```{=html}
<!-- -->
```
4.  It looks like when you use the `xlim` it zooms out but when you use the `ylim` it zooms in.

```{r}
ggplot(diamonds, aes(x = carat)) + geom_histogram(binwidth = .1) +
  coord_cartesian(xlim = c(0,50))

ggplot(diamonds, aes(x = carat)) + geom_histogram(binwidth = .1) + 
  coord_cartesian(ylim = c(0,50))
```

## 11.4.1 Exercises {.unnumbered}

1.  The missing values are removed with a warning.

2.  For mean it determines whether na's should be removed or not and for sum should na values be removed and certain other values.

## 11.5.1.1 Exercises {.unnumbered}

1.  

```{r}
canceled_flights <- nycflights13::flights |> 
  mutate(
    cancelled = is.na(dep_time),
    sched_hour = sched_dep_time %/% 100,
    sched_min = sched_dep_time %% 100,
    sched_dep_time = sched_hour + (sched_min / 60)
  ) 

ggplot(canceled_flights,aes(x = cancelled)) +
  geom_bar()
```

2.I would say maybe clarity or just straight up price,because the lower quality diamonds correspond to people buying them who don't really know about diamonds or don't care about the quality,theres alot more lower quality diamonds than higher quality.

?diamonds

3.  It switching the x and y its alot faster.

```{r}
ggplot(mpg, aes(x = hwy, y = fct_reorder(class, hwy, median))) +
  geom_boxplot() + coord_flip()
```

4.One problem with boxplots is that they were developed in an era of much smaller datasets and tend to display a prohibitively large number of "outlying values".
One approach to remedy this problem is the letter value plot.
Install the lvplot package, and try using `geom_lv()` to display the distribution of price vs.Â cut.
What do you learn?
How do you interpret the plots?

```{r}
ggplot(diamonds,aes(x = cut,y = price)) +
  geom_lv()
```

5.  geom_violin shows a basic understanding of the amount of diamonds while geom_histogram shows the further outliers better and where they are and geom_freqpoly shows the count better

```{r}
ggplot(diamonds,aes(x = price, y = clarity)) +
  geom_violin()
```

```{r}
ggplot(diamonds,aes(x = price)) +
  geom_histogram() +
  facet_wrap(~clarity, ncol = 1, scales = "free_y")
#> `stat_bin()` using `bins = 30`. Pick better value with `binwidth`
```

```{r}
ggplot(diamonds,aes(x = price, color = clarity)) +
  geom_freqpoly()
#> `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
```

6.  `geom_beeswarm()` makes it so you have more control over overplotting datasets, while geom_jitter to me seems like just a default that you can use on the go but if you do want more customization ggbeeswarm is better for handling overplotting.

## 11.5.2.1 Exercises {.unnumbered}

1.  

```{r}
ggplot(diamonds, aes(x = cut, y = color)) +
  geom_count()
```

2.  

```{r}
count(diamonds,color,cut)
 
 ggplot(diamonds,aes( x = color, fill = cut)) +
  geom_bar(position = "fill")
```

3.  

```{r}
nycflights13::flights |> 
  summarise(dest,month,year) |> 
  group_by(dest,month)
```

## 11.5.3.1 Exercises {.unnumbered}

```{r}
smaller <- diamonds |> 
  filter(carat < 3)
```

1.  If you want to use cut_width know you r datas values,if you use cut_number know your sample size.

```{r}
# visualize price binning by carat, cut_width()
ggplot(smaller, aes(x = price, y = ..density..,)) +
  geom_freqpoly(aes(color = cut_width(carat, 0.5)))

# visualize price binning by carat, cut_number(), 10 bins
ggplot(smaller, aes(x = price, y = ..density..,)) +
  geom_freqpoly(aes(color = cut_number(carat, 10)))
```

2.Visualize the distribution of `carat`, partitioned by `price`.

```{r}
ggplot(diamonds, aes(x = price, y = carat)) + 
  geom_boxplot()
```

3.  Its not what i expect even the large diamonds are the same price as smaller diamonds.

```{r}
ggplot(diamonds,aes(x = carat, y = price)) +
  geom_point()
```

4.  

```{r}
ggplot(diamonds,aes(x = price, color = cut, fill = cut)) +
  geom_freqpoly()
```

```{r}
ggplot(diamonds,aes(x = carat, color = cut, fill = cut)) +
  geom_freqpoly()
```

5.  This scatterplot shows outliers and binned plots don't.

```{r}
diamonds |> 
  filter(x >= 4) |> 
  ggplot(aes(x = x, y = y)) +
  geom_point() +
  coord_cartesian(xlim = c(4, 11), ylim = c(4, 11))
```

```{r}
diamonds |> 
  filter(x >= 4) |> 
ggplot(aes(x = x)) +
  geom_histogram()
```

6.  If you want to control the width you use cut_width, if you want to choose the number of bins use cut_number.

```{r}
ggplot(smaller, aes(x = carat, y = price)) + 
  geom_boxplot(aes(group = cut_number(carat, 20)))

smaller |> 
  mutate(carat_group = cut_number(carat,20)) |>
  count(carat_group)
```

```{r}
ggplot(smaller, aes(x = carat, y = price)) + 
  geom_boxplot(aes(group = cut_width(carat, .1)))

smaller |>
  mutate(carat_group = cut_width(carat,.1)) |> 
  count(carat_group)
```
