---
title: "Data transformation"
---

## Prerequisites

```{r}
library(nycflights13)
library(tidyverse)

#> ── Attaching packages ──────────────────────────────────── tidyverse 1.3.2 ──
#> ✔ ggplot2 3.4.0           ✔ purrr   1.0.1.9000 
#> ✔ tibble  3.1.8           ✔ dplyr   1.0.99.9000
#> ✔ tidyr   1.2.1.9001      ✔ stringr 1.5.0      
#> ✔ readr   2.1.3           ✔ forcats 0.5.2      
#> ── Conflicts ─────────────────────────────────────── tidyverse_conflicts() ──
#> ✖ dplyr::filter() masks stats::filter()
#> ✖ dplyr::lag()    masks stats::lag()
```

##Solutions

## 4.2.5 Exercises

1\. Pipelines for each part are given below.

a\.

```{r}
flights |>
filter(arr_delay >= 2) |> 
  arrange(desc(arr_delay))
```

b.

```{r}
flights |>
  filter(dest %in% c("IAH", "HOU"))
```

c.  

```{r}
flights |>
  filter(carrier %in% c("UA", "DL", "AA"))
```

d.  

```{r}
flights |>
  filter(month %in% c(7, 8, 9))
```

e.  

```{r}
flights |> 
  filter(dep_delay >= 0, arr_delay < -2)
```

f.  

```{r}
flights |> 
  filter(dep_delay <= -1, arr_delay > 30)
```

2.  Flights with longest departure delays and flights that left earliest in the morning.

```{r}
flights |> 
  arrange(desc(dep_delay)) |> 
  arrange(time_hour)
```

3. Flights with the fastest arrival times.

```{r}
flights |> 
  mutate(speed = distance / air_time)
```

4. Yes, there was a flight on every day of 2013.

```{r}
flights |> 
  distinct(year, month, day)
```

5. Flights traveled the farthest distance and shortest distance.

```{r}
flights |> 
  arrange(distance) 
```

```{r}
flights |> 
  arrange(desc(distance))
```

6. The order doesn't matter because we filter based on a condition, not based on row number.

## 4.3.5 Exercises

1.  Yes, these times do match.

    ```{r}
    flights |> 
      mutate(new = dep_time - sched_dep_time) |>
      relocate(new, dep_delay)
    ```

2. They show when a plane left when it was supposed to leave and if there was a delay.

```{r}
flights |>
select(dep_time:arr_delay, -c(contains("sched")))
```

```{r}
flights |> 
  select(dep_time, dep_delay, arr_time, arr_delay)
```

```{r}
select(flights, dep_time:arr_delay, -sched_dep_time,-sched_arr_time)
```

3.  Nothing happens, you just get the variable once.

```{r}
flights |> 
  select(dep_time, dep_time)
```

4. You ask if `any_of()` these variables have a certain thing you are looking for.

```{r}
variables <- c("year", "month", "day", "dep_delay", "arr_delay")

flights |> 
  select(any_of(variables))
  
```

5.  No it doesn't surprise me.it looks like case doesn't matter.i can change time to dep.

```{r}
select(flights, contains("TIME"))
```
6.
```{r}
flights |>
  mutate(air_time_min = air_time) |>
  relocate(air_time_min)
```

7. This doesn't work because the code has only 1 variable after selecting `tailnum` you can't arrange a variable that wasn't selected.
```{r}
flights |> 
  select(tailnum) |> 
  arrange(arr_delay)
#> Error in `arrange()`:
#> ℹ In argument: `..1 = arr_delay`.
#> Caused by error:
#> ! object 'arr_delay' not found
```
## 4.4.6 Exercises

1.  It looks like 9E has the worst delays.9E is a mexican airline called Endeavour Air.

```{r}
flights |> 
  group_by(carrier, dep_delay) |> 
  summarize(n())

flights |> 
  arrange(desc(dep_delay))
```

2.  
```{r}
flights |> 
  group_by(dest) |> 
  arrange(desc(dep_delay))
```

3.  

```{r}
ggplot(flights, aes(x = time_hour, y = dep_delay)) + 
  geom_smooth()
```

4.You get a error.

```{r}
#| error: true
flights |> 
  slice_min(-n)
```

5.  `count()` counts the number of observations in each group, setting the `sort` argument to `TRUE` arranges the categories in descending order of number of observations.

6.  

```{r}
df <- tibble(
  x = 1:5,
  y = c("a", "b", "a", "a", "b"),
  z = c("K", "K", "L", "L", "K")
)
```

a.It would group by y.

```{r}
df |>
  group_by(y)
```

b.What arrange did here is arranged y in alphabetical order in this case.

```{r}
df |>
  arrange(y)
```

c.  The pipeline tells the code what to do next, it groups by y then finds the average of x.

```{r}
df |>
  group_by(y) |>
  summarize(mean_x = mean(x))
```

d.  The code groups by y and z then averages x,then it shows theres a average of 1 k for a y,an average of 3.5 L's for the second a in y and an average of 3.5 k's for b.

```{r}
df |>
  group_by(y, z) |>
  summarize(mean_x = mean(x))
```

e.  This code completely gets rid of the group by part the function that does this is .groups = "drop".

```{r}
df |>
  group_by(y, z) |>
  summarize(mean_x = mean(x), .groups = "drop")
```

f.  These codes do the same thing the only difference is that the first code shows the information in a clean way due to `summarize()`.

```{r}
df |>
  group_by(y, z) |>
  summarize(mean_x = mean(x))

df |>
  group_by(y, z) |>
  mutate(mean_x = mean(x))
```
