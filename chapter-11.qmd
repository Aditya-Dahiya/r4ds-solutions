---
title: "Exploratory data analysis"
---


## Solutions

```{r}
library(tidyverse)
library(ggbeeswarm)
library(lvplot)
```

## Exercise 12.3.3

1. look up help ?diamonds

```{r}
ggplot(diamonds, aes(x = x , y = y)) + geom_point()
```

`x` is the length, `y` is the width, `z` is the depth

2.

```{r}
ggplot(diamonds, aes(x = price)) + geom_histogram(binwidth = 2000)
```

3.

```{r}
ggplot(diamonds, aes(x = carat)) + geom_histogram(binwidth = .1)
```

4. It looks like when you use the `xlim` it zooms out but when you use the `ylim` it zooms in.

```{r}
ggplot(diamonds, aes(x = carat)) + geom_histogram(binwidth = .1) +
  coord_cartesian(xlim = c(0,50))

ggplot(diamonds, aes(x = carat)) + geom_histogram(binwidth = .1) + 
  coord_cartesian(ylim = c(0,50))
```

## Exercise 12.4.1

1. The missing values are removed with a warning.

2. For mean it determines whether na's should be removed or not and for sum should na values be removed and certain other values.

## Exercise 12.5.1.1

1.

```{r}
canceled_flights <- nycflights13::flights |> 
  mutate(
    cancelled = is.na(dep_time),
    sched_hour = sched_dep_time %/% 100,
    sched_min = sched_dep_time %% 100,
    sched_dep_time = sched_hour + (sched_min / 60)
  ) 

ggplot(canceled_flights,aes(x = cancelled)) +
  geom_bar()
```

2.I would say maybe clarity or just straight up price,because the lower quality diamonds correspond to people buying them who don't really know about diamonds or don't care about the quality,theres alot more lower quality diamonds than higher quality.

?diamonds

3. It switching the x and y its alot faster.

```{r}
ggplot(mpg, aes(x = hwy, y = fct_reorder(class, hwy, median))) +
  geom_boxplot() + coord_flip()
```

4.One problem with boxplots is that they were developed in an era of much smaller datasets and tend to display a prohibitively large number of "outlying values". One approach to remedy this problem is the letter value plot. Install the lvplot package, and try using `geom_lv()` to display the distribution of price vs. cut. What do you learn? How do you interpret the plots?



```{r}
ggplot(diamonds,aes(x = cut,y = price)) +
  geom_lv()
```
5.Compare and contrast [`geom_violin()`](https://ggplot2.tidyverse.org/reference/geom_violin.html) with a faceted [`geom_histogram()`](https://ggplot2.tidyverse.org/reference/geom_histogram.html), or a colored [`geom_freqpoly()`](https://ggplot2.tidyverse.org/reference/geom_histogram.html). What are the pros and cons of each method?

geom_violin shows a basic understanding of the amount of diamonds while geom_histogram shows the further outliers better and where they are and geom_freqpoly shows the count better

```{r}
ggplot(diamonds,aes(x = price, y = clarity)) +
  geom_violin()
```

```{r}
ggplot(diamonds,aes(x = price)) +
  geom_histogram() +
  facet_wrap(~clarity, ncol = 1, scales = "free_y")
#> `stat_bin()` using `bins = 30`. Pick better value with `binwidth`
```

```{r}
ggplot(diamonds,aes(x = price, color = clarity)) +
  geom_freqpoly()
#> `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
```

6.If you have a small dataset, it's sometimes useful to use [`geom_jitter()`](https://ggplot2.tidyverse.org/reference/geom_jitter.html) to see the relationship between a continuous and categorical variable. The ggbeeswarm package provides a number of methods similar to [`geom_jitter()`](https://ggplot2.tidyverse.org/reference/geom_jitter.html). List them and briefly describe what each one does

so geom_beeswarm makes it so you have more control over overplotting datasets, while geom_jitter to me seems like just a default that you can use on the go but if you do want more customization ggbeeswarm is better for handling overplotting

## Exercise 12.5.2.1

1.How could you rescale the count dataset above to more clearly show the distribution of cut within color, or color within cut?

i can use this code from earlier that shows exactly that

```{r}

ggplot(diamonds, aes(x = cut, y = color)) +
  geom_count()
```

2.How does the segmented bar chart change if color is mapped to the `x` aesthetic and `cut` is mapped to the `fill` aesthetic? Calculate the counts that fall into each of the segments.

```{r}
count(diamonds,color,cut)
 
 ggplot(diamonds,aes( x = color, fill = cut)) +
  geom_bar(position = "fill")
```

3.Use [`geom_tile()`](https://ggplot2.tidyverse.org/reference/geom_tile.html) together with dplyr to explore how average flight delays vary by destination and month of year. What makes the plot difficult to read? How could you improve it?

```{r}
glimpse(nycflights13::flights)

nycflights13::flights %>% summarise(dest,month,year) %>% 
  group_by(dest,month)

```

## Exercise 12.5.3.1

```{r}
smaller <- diamonds |> 
  filter(carat < 3)
```

1.Instead of summarizing the conditional distribution with a boxplot, you could use a frequency polygon. What do you need to consider when using [`cut_width()`](https://ggplot2.tidyverse.org/reference/cut_interval.html) vs. [`cut_number()`](https://ggplot2.tidyverse.org/reference/cut_interval.html)? How does that impact a visualization of the 2d distribution of `carat` and `price`?

if you want to use cut_width know you r datas values,if you use cut_number know your sample size

```{r}
# visualize price binning by carat, cut_width()
ggplot(smaller, aes(x = price, y = ..density..,)) +
  geom_freqpoly(aes(color = cut_width(carat, 0.5)))

# visualize price binning by carat, cut_number(), 10 bins
ggplot(smaller, aes(x = price, y = ..density..,)) +
  geom_freqpoly(aes(color = cut_number(carat, 10)))
```

2.Visualize the distribution of `carat`, partitioned by `price`.

```{r}
ggplot(diamonds, aes(x = price, y = carat)) + 
  geom_boxplot()
```

3.How does the price distribution of very large diamonds compare to small diamonds? Is it as you expect, or does it surprise you?

its not what i expect even the large diamonds are the same price as smaller diamonds

```{r}

ggplot(diamonds,aes(x = carat,y = price)) +
  geom_point()
```

4.Combine two of the techniques you've learned to visualize the combined distribution of cut, carat, and price.

```{r}
ggplot(diamonds,aes(x = price,color = cut,fill = cut)) +
  geom_freqpoly()
```

```{r}
ggplot(diamonds,aes(x = carat,color = cut,fill = cut)) +
  geom_freqpoly()
```

5.Two dimensional plots reveal outliers that are not visible in one dimensional plots. For example, some points in the following plot have an unusual combination of `x` and `y` values, which makes the points outliers even though their `x` and `y` values appear normal when examined separately. Why is a scatterplot a better display than a binned plot for this case?

because this scatterplot shows outliers and binned plots don't

```{r}
diamonds |> 
  filter(x >= 4) |> 
  ggplot(aes(x = x, y = y)) +
  geom_point() +
  coord_cartesian(xlim = c(4, 11), ylim = c(4, 11))
```

```{r}
diamonds |> 
  filter(x >= 4) |> 
ggplot(aes(x = x)) +
  geom_histogram()
```

6.Instead of creating boxes of equal width with [`cut_width()`](https://ggplot2.tidyverse.org/reference/cut_interval.html), we could create boxes that contain roughly equal number of points with [`cut_number()`](https://ggplot2.tidyverse.org/reference/cut_interval.html). What are the advantages and disadvantages of this approach?

if you want to control the width you use cut_width, if you want to choose the number of bins use cut_number

```{r}
ggplot(smaller, aes(x = carat, y = price)) + 
  geom_boxplot(aes(group = cut_number(carat, 20)))

smaller %>% 
  mutate(carat_group = cut_number(carat,20)) %>% 
  count(carat_group)
```

```{r}
ggplot(smaller, aes(x = carat, y = price)) + 
  geom_boxplot(aes(group = cut_width(carat, .1)))

smaller %>% 
  mutate(carat_group = cut_width(carat,.1)) %>% 
  count(carat_group)
```
